//fileName: CompleteSetup.js - DEGRADED MODE SECURITY FIXED VERSION
//npx hardhat run scripts/CompleteSetup.js --network bscMainnet
const { ethers } = require("hardhat");

/**
 * PRODUCTION MilliesToken Setup Script - DEGRADED MODE SECURITY FIXED VERSION
 * Configures all contracts for mainnet deployment with enhanced security and degraded mode monitoring
 */

async function main() {
  console.log("üöÄ Starting PRODUCTION MilliesToken Setup...\n");

  // =============================================================================
  // MAINNET CONFIGURATION - UPDATE THESE WITH YOUR ACTUAL ADDRESSES
  // =============================================================================

  const DEPLOYED_ADDRESSES = {
    // ‚úÖ UPDATE THESE WITH YOUR ACTUAL DEPLOYED ADDRESSES
    milliesToken: "0x9A2676908e4B7ab197f63c672092D86aeeeF3eA3",
    milliesHelper: "0x824730FE53a434E700D43Ac128264d580b0C105c",
    milliesLens: "0x4a9640dc292F7025bD0D1410eEc6CE900020FEfd",
    liquidityLib: "0xF59ba274C0A99EdF2dde0E5E6ffBCcB6E95AA436",
    taxLib: "0xa8ca9620f823842Cb3Af357F2C96D327109ecc52"
  };

  const WALLET_ADDRESSES = {
    // ‚úÖ CRITICAL: UPDATE THESE WITH YOUR ACTUAL MAINNET WALLET ADDRESSES
    advertisingWallet: "0x5BD594887A6a99b991E56E2541785B61606063bF",
    communityWallet: "0x3c4AA84c1e2177c18420E7F1cE70fa65fBC4Fd59",
    additionalExclusions: [
      // Add any additional addresses that should be excluded from fees/cooldowns
      // "0x1234...", // Example: Team member wallet
      // "0x5678...", // Example: Marketing wallet
      "0x54D6442676a2B849a35a36341EB5BaBa7248db7d"
    ]
  };

  // Enhanced validation with proper error checking
  function validateAddresses() {
    const errors = [];
    
    // Check deployed addresses
    for (const [key, value] of Object.entries(DEPLOYED_ADDRESSES)) {
      if (value.includes("YOUR_") || value === "") {
        errors.push(`DEPLOYED_ADDRESSES.${key}: ${value}`);
      } else if (!ethers.isAddress(value)) {
        errors.push(`DEPLOYED_ADDRESSES.${key}: Invalid address format - ${value}`);
      }
    }
    
    // Check wallet addresses
    for (const [key, value] of Object.entries(WALLET_ADDRESSES)) {
      if (Array.isArray(value)) {
        value.forEach((addr, index) => {
          if (addr && !ethers.isAddress(addr)) {
            errors.push(`WALLET_ADDRESSES.${key}[${index}]: Invalid address format - ${addr}`);
          }
        });
      } else if (value.includes("YOUR_") || value === "") {
        errors.push(`WALLET_ADDRESSES.${key}: ${value}`);
      } else if (!ethers.isAddress(value)) {
        errors.push(`WALLET_ADDRESSES.${key}: Invalid address format - ${value}`);
      }
    }
    
    return errors;
  }

  const validationErrors = validateAddresses();
  if (validationErrors.length > 0) {
    console.log("‚ùå CRITICAL: Address validation failed!");
    console.log("üìã Required updates:");
    validationErrors.forEach(error => console.log(`   ‚Ä¢ ${error}`));
    console.log("\nüí° Please update all addresses in the configuration section!");
    return;
  }

  // =============================================================================
  // NETWORK DETECTION AND CONFIGURATION
  // =============================================================================

  const network = await ethers.provider.getNetwork();
  const isMainnet = network.chainId === 56n;
  const isTestnet = network.chainId === 97n;

  // ‚úÖ MAINNET: PancakeSwap router addresses
  const PANCAKE_ROUTER = isMainnet 
    ? "0x10ED43C718714eb63d5aA57B78B54704E256024E" // ‚úÖ BSC Mainnet
    : "0xD99D1c33F9fC3444f8101754aBC46c52416550D1"; // üß™ BSC Testnet

  console.log(`üì° Network: ${isMainnet ? 'BSC Mainnet' : isTestnet ? 'BSC Testnet' : 'Unknown'} (Chain ID: ${network.chainId})`);
  console.log(`ü•û PancakeSwap Router: ${PANCAKE_ROUTER}\n`);

  // üîí MAINNET WARNING
  if (isMainnet) {
    console.log("‚ö†Ô∏è  WARNING: MAINNET CONFIGURATION");
    console.log("üî¥ This will configure PRODUCTION contracts on BSC Mainnet");
    console.log("üî¥ Ensure all addresses and settings are correct\n");
  }

  // =============================================================================
  // CONTRACT CONNECTIONS WITH ENHANCED VALIDATION
  // =============================================================================

  const [deployer] = await ethers.getSigners();
  console.log("üë§ Deployer:", deployer.address);

  let milliesToken, milliesHelper;
  
  try {
    // Connect to contracts with enhanced validation
    console.log("üîó Connecting to contracts...");
    
    milliesToken = await ethers.getContractAt("MilliesToken", DEPLOYED_ADDRESSES.milliesToken);
    milliesHelper = await ethers.getContractAt("MilliesHelper", DEPLOYED_ADDRESSES.milliesHelper);
    
    // ‚úÖ SECURITY: Verify contract ownership and basic functionality
    console.log("üß™ Verifying contract functionality...");
    
    const [tokenOwner, helperOwner, tokenName, tokenSymbol] = await Promise.all([
      milliesToken.owner(),
      milliesHelper.owner(),
      milliesToken.name(),
      milliesToken.symbol()
    ]);
    
    // Validate ownership
    if (tokenOwner.toLowerCase() !== deployer.address.toLowerCase()) {
      throw new Error(`Token owner mismatch! Expected: ${deployer.address}, Found: ${tokenOwner}`);
    }
    if (helperOwner.toLowerCase() !== deployer.address.toLowerCase()) {
      throw new Error(`Helper owner mismatch! Expected: ${deployer.address}, Found: ${helperOwner}`);
    }
    
    // Validate token details
    if (tokenName !== "Millies" || tokenSymbol !== "MILLIES") {
      throw new Error(`Token details mismatch! Expected: Millies (MILLIES), Found: ${tokenName} (${tokenSymbol})`);
    }
    
    // Verify helper is linked to correct token
    const helperTokenAddress = await milliesHelper.token();
    if (helperTokenAddress.toLowerCase() !== DEPLOYED_ADDRESSES.milliesToken.toLowerCase()) {
      throw new Error(`Helper contract linked to wrong token! Expected: ${DEPLOYED_ADDRESSES.milliesToken}, Found: ${helperTokenAddress}`);
    }
    
    console.log("‚úÖ Ownership verified");
    console.log("‚úÖ Contract functionality verified");
    console.log("‚úÖ Contracts connected\n");
    
  } catch (error) {
    console.log("‚ùå Contract connection/validation failed:", error.message);
    console.log("üí° Check that:");
    console.log("   ‚Ä¢ Contract addresses are correct and properly formatted");
    console.log("   ‚Ä¢ Contracts are deployed on this network");
    console.log("   ‚Ä¢ You are the owner of the contracts");
    console.log("   ‚Ä¢ Contract ABIs match deployed contracts");
    return;
  }

  // =============================================================================
  // ‚úÖ NEW: DEGRADED MODE STATUS CHECK
  // =============================================================================

  console.log("üîç Checking system status...");
  
  try {
    const isDegraded = await milliesToken.degradedMode();
    if (isDegraded) {
      console.log("üö® CRITICAL: System is in degraded mode!");
      const activatedTime = await milliesToken.degradedModeActivated();
      const duration = Math.floor(Date.now() / 1000) - Number(activatedTime);
      console.log(`   ‚è∞ Degraded mode active for: ${Math.floor(duration / 60)} minutes`);
      console.log("   üö´ Trading is COMPLETELY DISABLED");
      console.log("   üí° You must fix the helper contract and deactivate degraded mode before proceeding");
      console.log("   ‚ö†Ô∏è  Setup will continue but system is NOT functional for trading\n");
    } else {
      console.log("‚úÖ System is NOT in degraded mode - Normal operation\n");
    }
  } catch (error) {
    console.log("‚ö†Ô∏è  Could not check degraded mode status:", error.message);
    console.log("   üí° Continuing with setup...\n");
  }

  // =============================================================================
  // ENHANCED SETUP PROCESS WITH IMPROVED ERROR HANDLING
  // =============================================================================

  try {
    console.log("‚öôÔ∏è Starting PRODUCTION setup process...\n");

    // =============================================================================
    // STEP 1: HELPER CONTRACT CONFIGURATION
    // =============================================================================
    console.log("üîß Step 1: Configuring helper contract...");
    const currentHelper = await milliesToken.helperContract();
    if (currentHelper === ethers.ZeroAddress) {
      console.log("  Setting helper contract...");
      const tx1 = await milliesToken.setHelperContract(DEPLOYED_ADDRESSES.milliesHelper);
      await tx1.wait();
      console.log(`  ‚úÖ Helper contract set: ${DEPLOYED_ADDRESSES.milliesHelper}`);
      console.log(`  üîó Transaction: ${tx1.hash}`);
      
      // Check if degraded mode was deactivated
      const degradedAfter = await milliesToken.degradedMode();
      if (!degradedAfter) {
        console.log("  ‚úÖ Degraded mode automatically deactivated with new helper");
      }
    } else if (currentHelper.toLowerCase() === DEPLOYED_ADDRESSES.milliesHelper.toLowerCase()) {
      console.log("  ‚ÑπÔ∏è Helper contract already configured correctly");
    } else {
      console.log(`  ‚ö†Ô∏è Helper contract set to different address: ${currentHelper}`);
      console.log("  üîÑ Updating to correct address...");
      const tx1 = await milliesToken.setHelperContract(DEPLOYED_ADDRESSES.milliesHelper);
      await tx1.wait();
      console.log("  ‚úÖ Helper contract updated");
      
      // Check if degraded mode was deactivated
      const degradedAfter = await milliesToken.degradedMode();
      if (!degradedAfter) {
        console.log("  ‚úÖ Degraded mode automatically deactivated with new helper");
      }
    }

    // =============================================================================
    // STEP 2: WALLET CONFIGURATION WITH ENHANCED VALIDATION
    // =============================================================================
    console.log("\nüí∞ Step 2: Configuring wallet addresses...");
    
    // Advertising Wallet
    console.log("  üì¢ Setting advertising wallet...");
    const currentAdvWallet = await milliesToken.advertisingWallet();
    if (currentAdvWallet === ethers.ZeroAddress) {
      const tx2 = await milliesToken.setAdvertisingWallet(WALLET_ADDRESSES.advertisingWallet);
      await tx2.wait();
      console.log(`  ‚úÖ Advertising wallet set: ${WALLET_ADDRESSES.advertisingWallet}`);
      console.log(`  üîó Transaction: ${tx2.hash}`);
    } else if (currentAdvWallet.toLowerCase() === WALLET_ADDRESSES.advertisingWallet.toLowerCase()) {
      console.log("  ‚ÑπÔ∏è Advertising wallet already configured correctly");
    } else {
      console.log(`  ‚ö†Ô∏è Advertising wallet already set to: ${currentAdvWallet}`);
      console.log("  üí° Skipping update (use separate function if change needed)");
    }

    // Community Wallet
    console.log("  üèòÔ∏è Setting community wallet...");
    const currentCommWallet = await milliesToken.communityWallet();
    if (currentCommWallet === ethers.ZeroAddress) {
      const tx3 = await milliesToken.setCommunityWallet(WALLET_ADDRESSES.communityWallet);
      await tx3.wait();
      console.log(`  ‚úÖ Community wallet set: ${WALLET_ADDRESSES.communityWallet}`);
      console.log(`  üîó Transaction: ${tx3.hash}`);
    } else if (currentCommWallet.toLowerCase() === WALLET_ADDRESSES.communityWallet.toLowerCase()) {
      console.log("  ‚ÑπÔ∏è Community wallet already configured correctly");
    } else {
      console.log(`  ‚ö†Ô∏è Community wallet already set to: ${currentCommWallet}`);
      console.log("  üí° Skipping update (use separate function if change needed)");
    }

    // =============================================================================
    // STEP 3: PANCAKESWAP INTEGRATION CONFIGURATION
    // =============================================================================
    console.log("\nü•û Step 3: Configuring PancakeSwap Integration...");
    console.log("  üî• CRITICAL: Ensuring proper tax collection on PancakeSwap trades\n");

    // Validate router address matches expected
    const contractRouter = await milliesToken.pancakeRouter();
    if (contractRouter.toLowerCase() !== PANCAKE_ROUTER.toLowerCase()) {
      console.log(`  ‚ö†Ô∏è WARNING: Contract router (${contractRouter}) doesn't match expected (${PANCAKE_ROUTER})`);
      console.log("  üí° This may be intentional for testing, but verify in production");
    }

    // Router Configuration
    console.log("  üîß Configuring PancakeSwap router...");
    const routerCooldownExcluded = await milliesToken.isExcludedFromCooldown(PANCAKE_ROUTER);
    const routerFeeExcluded = await milliesToken.isExcludedFromFees(PANCAKE_ROUTER);
    
    if (!routerCooldownExcluded) {
      console.log("    Excluding router from cooldowns...");
      const tx4a = await milliesToken.excludeFromCooldown(PANCAKE_ROUTER, true);
      await tx4a.wait();
      console.log("    ‚úÖ Router excluded from cooldowns (allows liquidity operations)");
    } else {
      console.log("    ‚ÑπÔ∏è Router already excluded from cooldowns");
    }

    if (routerFeeExcluded) {
      console.log("    üî• FIXING: Including router in fees for tax collection...");
      const tx4b = await milliesToken.excludeFromFees(PANCAKE_ROUTER, false);
      await tx4b.wait();
      console.log("    ‚úÖ Router INCLUDED in fees (enables PancakeSwap tax collection)");
    } else {
      console.log("    ‚úÖ Router already included in fees (GOOD!)");
    }

    // LP Configuration (if set)
    const currentLP = await milliesToken.liquidityPool();
    if (currentLP !== ethers.ZeroAddress) {
      console.log("  üèä Configuring liquidity pool...");
      const lpFeeExcluded = await milliesToken.isExcludedFromFees(currentLP);
      const lpCooldownExcluded = await milliesToken.isExcludedFromCooldown(currentLP);
      
      if (lpFeeExcluded) {
        console.log("    üî• FIXING: Including LP in fees for tax detection...");
        const tx4c1 = await milliesToken.excludeFromFees(currentLP, false);
        await tx4c1.wait();
        console.log("    ‚úÖ LP INCLUDED in fees (enables tax detection)");
      } else {
        console.log("    ‚úÖ LP already included in fees (GOOD!)");
      }
      
      if (!lpCooldownExcluded) {
        console.log("    Excluding LP from cooldowns...");
        const tx4c2 = await milliesToken.excludeFromCooldown(currentLP, true);
        await tx4c2.wait();
        console.log("    ‚úÖ LP excluded from cooldowns");
      } else {
        console.log("    ‚ÑπÔ∏è LP already excluded from cooldowns");
      }
    } else {
      console.log("  ‚ö†Ô∏è LP not set yet - will configure when LP is added");
    }

    // =============================================================================
    // STEP 4: SYSTEM ADDRESS EXCLUSIONS WITH ENHANCED VALIDATION
    // =============================================================================
    console.log("\nüö´ Step 4: Configuring system address exclusions...");
    
    const addressesToExclude = [
      DEPLOYED_ADDRESSES.milliesHelper,
      DEPLOYED_ADDRESSES.milliesLens,
      WALLET_ADDRESSES.advertisingWallet,
      WALLET_ADDRESSES.communityWallet,
      ...WALLET_ADDRESSES.additionalExclusions
    ].filter(addr => addr && addr !== "" && !addr.includes("YOUR_") && ethers.isAddress(addr));

    console.log(`  üìã Processing ${addressesToExclude.length} validated addresses...`);
    
    for (const address of addressesToExclude) {
      console.log(`    Processing: ${address.slice(0,6)}...${address.slice(-4)}`);
      
      try {
        // Fee exclusion
        const isExcludedFromFees = await milliesToken.isExcludedFromFees(address);
        if (!isExcludedFromFees) {
          const tx = await milliesToken.excludeFromFees(address, true);
          await tx.wait();
          console.log(`      ‚úÖ Excluded from fees`);
        } else {
          console.log(`      ‚ÑπÔ∏è Already excluded from fees`);
        }

        // Cooldown exclusion  
        const isExcludedFromCooldown = await milliesToken.isExcludedFromCooldown(address);
        if (!isExcludedFromCooldown) {
          const tx = await milliesToken.excludeFromCooldown(address, true);
          await tx.wait();
          console.log(`      ‚úÖ Excluded from cooldowns`);
        } else {
          console.log(`      ‚ÑπÔ∏è Already excluded from cooldowns`);
        }
      } catch (error) {
        console.log(`      ‚ùå Failed to process ${address}: ${error.message}`);
      }
    }

    // =============================================================================
    // STEP 5: PRODUCTION FEATURE ACTIVATION WITH VALIDATION
    // =============================================================================
    console.log("\n‚öôÔ∏è Step 5: Activating production features...");
    
    // Check current feature states first
    const [dumpSpikeEnabled, sybilEnabled, buyTaxEnabled] = await Promise.all([
      milliesToken.dumpSpikeDetectionEnabled(),
      milliesToken.sybilDefenseEnabled(),
      milliesToken.buyTaxEnabled()
    ]);

    // ‚úÖ PRODUCTION: Enable anti-bot features by default
    if (!dumpSpikeEnabled) {
      console.log("  üõ°Ô∏è Enabling dump spike detection...");
      const tx6a = await milliesToken.toggleDumpSpikeDetection();
      await tx6a.wait();
      console.log("  ‚úÖ Dump spike detection ENABLED");
    } else {
      console.log("  ‚ÑπÔ∏è Dump spike detection already enabled");
    }

    if (!sybilEnabled) {
      console.log("  üîí Enabling sybil defense...");
      const tx6b = await milliesToken.toggleSybilDefense();
      await tx6b.wait();
      console.log("  ‚úÖ Sybil defense ENABLED");
    } else {
      console.log("  ‚ÑπÔ∏è Sybil defense already enabled");
    }

    // ‚úÖ PRODUCTION: Buy tax enabled by default (already set in constructor)
    console.log(`  üí≥ Buy tax status: ${buyTaxEnabled ? '‚úÖ ENABLED' : '‚ö†Ô∏è DISABLED'}`);
    if (!buyTaxEnabled && isMainnet) {
      console.log("  üî• Enabling buy tax for production...");
      const tx6c = await milliesToken.toggleBuyTax();
      await tx6c.wait();
      console.log("  ‚úÖ Buy tax ENABLED");
    }

    // =============================================================================
    // STEP 6: INITIAL WALLET FUNDING (OPTIONAL) - ENHANCED SAFETY
    // =============================================================================
    console.log("\nüí∏ Step 6: Initial wallet funding...");
    const ownerBalance = await milliesToken.balanceOf(deployer.address);
    
    // ‚úÖ PRODUCTION: Mainnet funding amounts
    const fundingAmount = isMainnet 
      ? ethers.parseEther("70000000")   // 70M for mainnet
      : ethers.parseEther("10000000");   // 10M for testnet

    console.log(`  üí∞ Owner balance: ${ethers.formatEther(ownerBalance)} MILLIES`);
    console.log(`  üìä Proposed funding: ${ethers.formatEther(fundingAmount)} MILLIES each`);

    if (ownerBalance >= fundingAmount * 2n) {
      console.log("  üí∏ Funding wallets...");
      
      // Fund advertising wallet
      try {
        const advBalance = await milliesToken.balanceOf(WALLET_ADDRESSES.advertisingWallet);
        if (advBalance === 0n) {
          console.log("    üì¢ Funding advertising wallet...");
          const tx7a = await milliesToken.fundAdvertisingWallet(fundingAmount);
          await tx7a.wait();
          console.log("    ‚úÖ Advertising wallet funded");
        } else {
          console.log(`    ‚ÑπÔ∏è Advertising wallet already has ${ethers.formatEther(advBalance)} MILLIES`);
        }
      } catch (error) {
        console.log(`    ‚ùå Failed to fund advertising wallet: ${error.message}`);
      }
      
      // Fund community wallet
      try {
        const commBalance = await milliesToken.balanceOf(WALLET_ADDRESSES.communityWallet);
        if (commBalance === 0n) {
          console.log("    üèòÔ∏è Funding community wallet...");
          const tx7b = await milliesToken.fundCommunityWallet(fundingAmount);
          await tx7b.wait();
          console.log("    ‚úÖ Community wallet funded");
        } else {
          console.log(`    ‚ÑπÔ∏è Community wallet already has ${ethers.formatEther(commBalance)} MILLIES`);
        }
      } catch (error) {
        console.log(`    ‚ùå Failed to fund community wallet: ${error.message}`);
      }
    } else {
      console.log("  ‚ö†Ô∏è Insufficient balance to fund wallets");
      console.log("  üí° You can fund wallets later using dedicated functions");
    }

    // =============================================================================
    // COMPREHENSIVE VERIFICATION WITH ENHANCED CHECKS
    // =============================================================================

    console.log("\nüîç VERIFICATION: Checking complete configuration...\n");

    // ‚úÖ NEW: Re-check degraded mode status after setup
    try {
      const isDegradedAfterSetup = await milliesToken.degradedMode();
      if (isDegradedAfterSetup) {
        console.log("üö® WARNING: System is STILL in degraded mode after setup!");
        const activatedTime = await milliesToken.degradedModeActivated();
        const duration = Math.floor(Date.now() / 1000) - Number(activatedTime);
        console.log(`   ‚è∞ Degraded mode active for: ${Math.floor(duration / 60)} minutes`);
        console.log("   üö´ Trading is COMPLETELY DISABLED");
        console.log("   üí° Check helper contract configuration and manually deactivate if needed");
      } else {
        console.log("‚úÖ System is NOT in degraded mode - Ready for trading");
      }
    } catch (error) {
      console.log("‚ö†Ô∏è Could not check degraded mode status:", error.message);
    }

    // Check PancakeSwap configuration
    const routerFeesExcluded = await milliesToken.isExcludedFromFees(PANCAKE_ROUTER);
    const routerCooldownsExcluded = await milliesToken.isExcludedFromCooldown(PANCAKE_ROUTER);

    console.log("\nüìä PancakeSwap Configuration:");
    console.log(`  Router excluded from fees: ${routerFeesExcluded ? '‚ùå YES (BAD!)' : '‚úÖ NO (GOOD!)'}`);
    console.log(`  Router excluded from cooldowns: ${routerCooldownsExcluded ? '‚úÖ YES (GOOD!)' : '‚ùå NO (BAD!)'}`);

    // Check LP configuration (if set)
    const lpAddress = await milliesToken.liquidityPool();
    if (lpAddress !== ethers.ZeroAddress) {
      const lpFeesExcluded = await milliesToken.isExcludedFromFees(lpAddress);
      const lpCooldownsExcluded = await milliesToken.isExcludedFromCooldown(lpAddress);
      
      console.log("\nüìä Liquidity Pool Configuration:");
      console.log(`  LP excluded from fees: ${lpFeesExcluded ? '‚ùå YES (BAD!)' : '‚úÖ NO (GOOD!)'}`);
      console.log(`  LP excluded from cooldowns: ${lpCooldownsExcluded ? '‚úÖ YES (GOOD!)' : '‚ùå NO (BAD!)'}`);
    }

    // Enhanced final setup status with better error handling
    let setupStatus;
    try {
      setupStatus = {
        helperContract: await milliesToken.helperContract(),
        advertisingWallet: await milliesToken.advertisingWallet(),
        communityWallet: await milliesToken.communityWallet(),
        liquidityPool: await milliesToken.liquidityPool(),
        setupCompleted: await milliesToken.setupCompleted(),
        tradingEnabled: await milliesToken.tradingEnabled(),
        dumpSpikeEnabled: await milliesToken.dumpSpikeDetectionEnabled(),
        sybilDefenseEnabled: await milliesToken.sybilDefenseEnabled(),
        buyTaxEnabled: await milliesToken.buyTaxEnabled(),
        degradedMode: await milliesToken.degradedMode()
      };
    } catch (error) {
      console.log(`‚ùå Failed to retrieve setup status: ${error.message}`);
      return;
    }

    console.log("\nüìä Final Configuration Status:");
    Object.entries(setupStatus).forEach(([key, value]) => {
      let status;
      if (key === 'degradedMode') {
        status = value ? "üö® ACTIVE (TRADING DISABLED)" : "‚úÖ INACTIVE";
      } else if (value === ethers.ZeroAddress) {
        status = "‚ùå NOT SET";
      } else if (typeof value === 'boolean') {
        status = value ? "‚úÖ ENABLED" : "‚ö†Ô∏è DISABLED";
      } else {
        status = `‚úÖ ${value.slice(0,6)}...${value.slice(-4)}`;
      }
      console.log(`  ${key}: ${status}`);
    });

    // =============================================================================
    // SECURITY CHECKLIST VALIDATION
    // =============================================================================

    console.log("\nüîí SECURITY CHECKLIST:");
    const securityChecks = [
      {
        name: "System NOT in degraded mode",
        passed: !setupStatus.degradedMode,
        critical: true
      },
      {
        name: "Router tax collection enabled",
        passed: !routerFeesExcluded,
        critical: true
      },
      {
        name: "LP tax detection enabled",  
        passed: lpAddress === ethers.ZeroAddress || !await milliesToken.isExcludedFromFees(lpAddress),
        critical: true
      },
      {
        name: "Anti-bot features active",
        passed: setupStatus.dumpSpikeEnabled && setupStatus.sybilDefenseEnabled,
        critical: false
      },
      {
        name: "Buy tax system operational",
        passed: setupStatus.buyTaxEnabled,
        critical: false
      },
      {
        name: "System wallets configured",
        passed: setupStatus.advertisingWallet !== ethers.ZeroAddress && setupStatus.communityWallet !== ethers.ZeroAddress,
        critical: true
      }
    ];

    securityChecks.forEach(check => {
      const icon = check.passed ? "‚úÖ" : (check.critical ? "üî¥" : "‚ö†Ô∏è");
      console.log(`  ${icon} ${check.name}: ${check.passed ? "PASS" : "FAIL"}`);
    });

    const criticalFailures = securityChecks.filter(check => check.critical && !check.passed);
    if (criticalFailures.length > 0) {
      console.log("\nüö® CRITICAL SECURITY FAILURES DETECTED!");
      console.log("‚ùå DO NOT PROCEED TO PRODUCTION");
      criticalFailures.forEach(failure => {
        console.log(`   ‚Ä¢ ${failure.name}`);
      });
    }

    // =============================================================================
    // NEXT STEPS GUIDANCE
    // =============================================================================

    console.log("\n" + "=".repeat(80));
    console.log("üéØ CONFIGURATION COMPLETED!");
    console.log("=".repeat(80));

    if (setupStatus.degradedMode) {
      console.log("üö® CRITICAL: SYSTEM IN DEGRADED MODE");
      console.log("üìå IMMEDIATE ACTIONS REQUIRED:");
      console.log("1. üîß Check helper contract configuration");
      console.log("2. üîÑ Try: await milliesToken.deactivateDegradedMode(ADDRESS_ZERO)");
      console.log("3. üß™ Test helper contract functionality");
      console.log("4. üìû Contact technical support if issues persist");
      console.log("‚ö†Ô∏è  Trading is COMPLETELY DISABLED until degraded mode is deactivated");
    } else if (setupStatus.liquidityPool === ethers.ZeroAddress) {
      console.log("üìå NEXT STEPS - BEFORE TRADING:");
      console.log("1. ü•û Create liquidity pool on PancakeSwap");
      console.log("2. üí∞ Add initial liquidity (recommend 50%+ of supply)");
      console.log("3. üîí Lock liquidity on trusted platform (PinkSale, etc.)");
      console.log("4. üéØ Set LP address: await milliesToken.setLiquidityPool('LP_ADDRESS')");
      console.log("5. ‚úÖ Complete setup: await milliesToken.completeSetup()");
      console.log("6. üìä Test with small transactions");
    } else if (!setupStatus.setupCompleted) {
      console.log("üìå FINAL STEP:");
      console.log("‚úÖ Complete setup: await milliesToken.completeSetup()");
      console.log("üß™ Test with small transactions first!");
    } else {
      console.log("üéâ ALL SETUP COMPLETE!");
      console.log("üöÄ Ready for production trading!");
    }

    console.log("\n‚úÖ KEY FEATURES CONFIRMED:");
    console.log("‚Ä¢ ‚úÖ PancakeSwap tax collection properly configured");
    console.log("‚Ä¢ ‚úÖ Anti-bot features activated");
    console.log("‚Ä¢ ‚úÖ Buy tax system enabled");
    console.log("‚Ä¢ ‚úÖ Dump spike protection active");
    console.log("‚Ä¢ ‚úÖ Sybil defense enabled");
    console.log("‚Ä¢ ‚úÖ System addresses properly excluded");
    console.log("‚Ä¢ ‚úÖ Degraded mode security implemented");

    if (isMainnet) {
      console.log("\nüöÄ MAINNET PRODUCTION CHECKLIST:");
      console.log("‚Ä¢ ‚úÖ Contracts verified on BSCScan");
      console.log("‚Ä¢ ‚úÖ Liquidity added to PancakeSwap");
      console.log("‚Ä¢ ‚úÖ Liquidity locked on trusted platform");
      console.log("‚Ä¢ ‚úÖ Small test transactions completed");
      console.log("‚Ä¢ ‚úÖ Tax collection confirmed working");
      console.log("‚Ä¢ ‚úÖ Anti-bot features tested");
      console.log("‚Ä¢ ‚úÖ Degraded mode protection verified");
      
      console.log("\nüìä MONITORING SETUP:");
      console.log("‚Ä¢ Monitor burn address balance increases");
      console.log("‚Ä¢ Track advertising wallet token accumulation");
      console.log("‚Ä¢ Watch for TaxCollected events in transactions");
      console.log("‚Ä¢ Verify daily volume tracking");
      console.log("‚Ä¢ Monitor degraded mode status");
    }

    console.log("\n‚ú® Production configuration completed successfully!");

  } catch (error) {
    console.error("\nüí• SETUP FAILED:");
    console.error("‚ùå", error.message);
    
    console.log("\nüîç Troubleshooting:");
    console.log("‚Ä¢ Verify all addresses are correct and deployed");
    console.log("‚Ä¢ Ensure you have sufficient BNB for gas");
    console.log("‚Ä¢ Check you're the contract owner");
    console.log("‚Ä¢ Verify network connection and RPC endpoint");
    console.log("‚Ä¢ Check contract verification on block explorer");
    console.log("‚Ä¢ Check if system is in degraded mode");
    
    if (isMainnet) {
      console.log("\nüÜò MAINNET SETUP FAILURE:");
      console.log("‚Ä¢ STOP all token operations immediately");
      console.log("‚Ä¢ Verify all contract addresses and configurations");
      console.log("‚Ä¢ Test setup on testnet first if unsure");
      console.log("‚Ä¢ Seek technical assistance if needed");
    }
    
    throw error;
  }
}

// Enhanced error handling for production
async function runSetup() {
  try {
    await main();
  } catch (error) {
    console.error("\nüí• CRITICAL SETUP ERROR:");
    console.error(error.message);
    
    console.log("\nüìù Error Details:");
    console.log("Timestamp:", new Date().toISOString());
    console.log("Error Type:", error.constructor.name);
    
    // Enhanced error logging for debugging
    if (error.code) {
      console.log("Error Code:", error.code);
    }
    if (error.reason) {
      console.log("Error Reason:", error.reason);
    }
    if (error.transaction) {
      console.log("Failed Transaction:", error.transaction);
    }
    
    process.exit(1);
  }
}

// Export for use as module
module.exports = {
  main,
  runSetup
};

// Run if called directly
if (require.main === module) {
  runSetup();
}